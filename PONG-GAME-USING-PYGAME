import pygame
import random

# constants for the windows width and height values
SCREEN_WIDTH = 960
SCREEN_HEIGHT = 720

# the RGB values for the colors used in the game
COLOR_BLACK = (0, 0, 0)
COLOR_WHITE = (255, 255, 255)


def reset_ball(ball_rect):
    """
    Reset the ball to the center of the screen and give it a new random direction.

    This function is called after a player scores.
    Keeping it in a separate function avoids duplicate code and
    makes the logic easier to reuse and change later.
    """
    ball_rect.center = (SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2)

    # determine the x and y speed of the ball
    ball_accel_x = random.randint(2, 4) * 0.1
    ball_accel_y = random.randint(2, 4) * 0.1

    # randomize the direction of the ball
    if random.randint(1, 2) == 1:
        ball_accel_x *= -1
    if random.randint(1, 2) == 1:
        ball_accel_y *= -1

    return ball_accel_x, ball_accel_y


def draw_text_center(screen, text, size, y):
    """
    Helper function to draw centered text on a given y position.

    This avoids repeating the same font/render/blit code for
    messages like "Press Space to Start", scores, and win messages.
    """
    font = pygame.font.SysFont('Consolas', size)
    text_surf = font.render(text, True, COLOR_WHITE)
    text_rect = text_surf.get_rect(center=(SCREEN_WIDTH // 2, y))
    screen.blit(text_surf, text_rect)


def game_over_screen(screen, clock, score_1, score_2, winner_text):
    """
    Show the game over screen when a player reaches the target score.

    - Displays who won and the final scores.
    - Waits for the player to press Space to play again.
    - Pressing ESC or closing the window will quit the game.

    This function is its own loop so the main game loop stays clean.
    """
    while True:
        screen.fill(COLOR_BLACK)

        # Winner message
        draw_text_center(screen, winner_text, 50, SCREEN_HEIGHT // 2 - 80)

        # Final scores
        draw_text_center(
            screen,
            f"Final Score  P1: {score_1}  -  P2: {score_2}",
            35,
            SCREEN_HEIGHT // 2 - 20,
        )

        # Play again / quit instructions
        draw_text_center(screen, "Press SPACE to Play Again", 30, SCREEN_HEIGHT // 2 + 40)
        draw_text_center(screen, "Press ESC to Quit", 30, SCREEN_HEIGHT // 2 + 80)

        pygame.display.flip()
        clock.tick(60)

        # Event loop for the game over screen
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                # Quit the entire program
                pygame.quit()
                raise SystemExit
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_SPACE:
                    # Start a new game
                    return  # return to main() so it can restart the game loop
                if event.key == pygame.K_ESCAPE:
                    pygame.quit()
                    raise SystemExit


def main():
    """
    Main function that runs the entire Pong game.

    It handles:
    - Game initialization
    - Input handling
    - Updating positions and collision detection
    - Scoring and win condition
    - Rendering all objects to the screen
    """
    # GAME SETUP

    # initialize the PyGame library (this is absolutely necessary)
    pygame.init()

    # this creates the window for the game
    screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))

    # set the window's title
    pygame.display.set_caption('Pong')

    # create the clock object to keep track of the time
    clock = pygame.time.Clock()

    # main loop to allow replaying the game without restarting the script
    while True:
        # scores for both players
        score_1 = 0
        score_2 = 0

        # target score to win
        target_score = 5

        """
        this is to check whether or not to move the ball
        the ball will start moving after the player presses Space
        """
        started = False

        """
        these are the players' game paddles
        the `Rect` function needs the x, y, width and height
        of the rectangles we will be drawing
        """
        paddle_1_rect = pygame.Rect(30, SCREEN_HEIGHT // 2 - 50, 7, 100)
        paddle_2_rect = pygame.Rect(SCREEN_WIDTH - 50, SCREEN_HEIGHT // 2 - 50, 7, 100)

        # this is to track by how much the players' paddles will move per frame
        paddle_1_move = 0
        paddle_2_move = 0

        # this is the rectangle that represents the ball
        ball_rect = pygame.Rect(SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2, 25, 25)

        # initialize ball speed and direction using helper
        ball_accel_x, ball_accel_y = reset_ball(ball_rect)

        # SINGLE GAME LOOP (ends when someone reaches target_score)
        running = True
        while running:
            """
            set the background color to black
            needs to be called every frame before drawing anything
            """
            screen.fill(COLOR_BLACK)

            # START SCREEN (waiting for Space to start ball movement)
            if not started:
                draw_text_center(screen, "Press Space to Start", 30, SCREEN_HEIGHT // 2 - 50)
                draw_text_center(screen, f"P1: {score_1}   P2: {score_2}", 30, SCREEN_HEIGHT // 2 + 10)
                pygame.display.flip()
                clock.tick(60)

                for event in pygame.event.get():
                    if event.type == pygame.QUIT:
                        pygame.quit()
                        return
                    if event.type == pygame.KEYDOWN:
                        if event.key == pygame.K_SPACE:
                            started = True
                # skip the rest of the loop until started becomes True
                continue

            """
            get the time elapsed between now and the last frame
            using delta time keeps movement consistent across machines
            """
            delta_time = clock.tick(60)

            # checking for events
            for event in pygame.event.get():

                # if the user exits the window
                if event.type == pygame.QUIT:
                    # exit the function, to finish the game
                    pygame.quit()
                    return

                # if the user is pressing a key
                if event.type == pygame.KEYDOWN:

                    # PLAYER 1
                    # if the key is W, set the movement of paddle_1 to go up
                    if event.key == pygame.K_w:
                        paddle_1_move = -0.5

                    # if the key is S, set the movement of paddle_1 to go down
                    if event.key == pygame.K_s:
                        paddle_1_move = 0.5

                    # PLAYER 2
                    # if the key is the up arrow, set the movement of paddle_2 to go up
                    if event.key == pygame.K_UP:
                        paddle_2_move = -0.5
                    # if the key is the down arrow, set the movement of paddle_2 to go down
                    if event.key == pygame.K_DOWN:
                        paddle_2_move = 0.5

                # if the player released a key
                if event.type == pygame.KEYUP:
                    # if the key released is w or s, stop the movement of paddle_1
                    if event.key == pygame.K_w or event.key == pygame.K_s:
                        paddle_1_move = 0.0

                    # if the key released is the up or down arrow, stop the movement of paddle_2
                    if event.key == pygame.K_UP or event.key == pygame.K_DOWN:
                        paddle_2_move = 0.0

            """
            move paddle_1 and paddle_2 according to their `move` variables
            we also multiply the `move` variable by the delta time to keep movement consistent through frames
            """
            paddle_1_rect.top += paddle_1_move * delta_time
            paddle_2_rect.top += paddle_2_move * delta_time

            # keep paddles inside the screen bounds
            if paddle_1_rect.top < 0:
                paddle_1_rect.top = 0
            if paddle_1_rect.bottom > SCREEN_HEIGHT:
                paddle_1_rect.bottom = SCREEN_HEIGHT

            if paddle_2_rect.top < 0:
                paddle_2_rect.top = 0
            if paddle_2_rect.bottom > SCREEN_HEIGHT:
                paddle_2_rect.bottom = SCREEN_HEIGHT

            # ball collision with top/bottom walls
            if ball_rect.top < 0:
                ball_accel_y *= -1
                ball_rect.top = 0
            if ball_rect.bottom >= SCREEN_HEIGHT:
                ball_accel_y *= -1
                ball_rect.bottom = SCREEN_HEIGHT

            # SCORING: ball goes out of bounds left/right
            if ball_rect.right <= 0:
                # player 2 scores
                score_2 += 1
                # reset ball to center and random direction
                ball_accel_x, ball_accel_y = reset_ball(ball_rect)
                started = False  # pause until player presses Space again
            elif ball_rect.left >= SCREEN_WIDTH:
                # player 1 scores
                score_1 += 1
                ball_accel_x, ball_accel_y = reset_ball(ball_rect)
                started = False

            # check win condition
            if score_1 >= target_score or score_2 >= target_score:
                # decide winner text
                if score_1 > score_2:
                    winner_text = "Player 1 Wins!"
                elif score_2 > score_1:
                    winner_text = "Player 2 Wins!"
                else:
                    winner_text = "Draw!"

                # show game over screen and ask to play again
                game_over_screen(screen, clock, score_1, score_2, winner_text)
                # break out of this game loop and start a fresh game (outer while True)
                running = False
                break

            """
            if paddle_1_rect collides with the ball and the ball is in front of it,
            change the speed of the ball and make it move a little in the other way
            """
            if paddle_1_rect.colliderect(ball_rect) and paddle_1_rect.left < ball_rect.left:
                ball_accel_x *= -1
                ball_rect.left += 5
            # do the same with paddle_2_rect
            if paddle_2_rect.colliderect(ball_rect) and paddle_2_rect.left > ball_rect.left:
                ball_accel_x *= -1
                ball_rect.left -= 5

            # move the ball when the game is started
            if started:
                ball_rect.left += ball_accel_x * delta_time
                ball_rect.top += ball_accel_y * delta_time

            # draw player 1 and player 2's rects with the white color
            pygame.draw.rect(screen, COLOR_WHITE, paddle_1_rect)
            pygame.draw.rect(screen, COLOR_WHITE, paddle_2_rect)

            # draw the ball with the white color
            pygame.draw.rect(screen, COLOR_WHITE, ball_rect)

            # draw the current score at the top center
            draw_text_center(screen, f"{score_1} : {score_2}", 40, 40)

            # update the display (this is necessary for Pygame)
            pygame.display.update()


# run the game
if __name__ == '__main__':
    main()
